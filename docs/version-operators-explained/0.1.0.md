---
id: 0.1.0
title: Version Operators Explained v0.1.0
sidebar_label: Version Operators Explained
sidebar_position: 1
hide_table_of_contents: false
custom_edit_url: null
---


# Version Operators Explained

![Version](https://img.shields.io/badge/version-0.1.0-blue) ![Latest](https://img.shields.io/badge/latest-✓-green) ![Pre-release](https://img.shields.io/badge/stability-pre--release-orange) <span title="Essential reading for Canon Protocol users">![Guide](https://img.shields.io/badge/Guide-lightblue)</span>

**Publisher:** canon-protocol.org  
**Type:** [`canon-protocol.org/blog-post@0.1.0`](/blog-post/0.1.0)  
**Composes:** [`canon-protocol.org/artifact-manifest@0.1.0`](/artifact-manifest/0.1.0)  

A comprehensive guide to when and where to use version operators in Canon Protocol




## Content

:::info Article Info
**Author:** Canon Protocol Team  
**Date:** 2024-01-30  
**Tags:** `documentation`, `version-operators`, `best-practices`, `guide`, `canon-protocol`  
:::

> Learn the critical distinction between exact versions and version operators in Canon Protocol, and why getting this right is essential for specification predictability and tool compatibility.

# Understanding Version Operators in Canon Protocol

One of the most important concepts in Canon Protocol is knowing when to use exact versions versus version operators (`^` and `~`). Getting this wrong can break tooling and create unpredictable specifications.

## The Golden Rule

**Version operators are ONLY allowed in schema ref types and project dependencies.**

Everything else MUST use exact versions. Let's understand why.

## Structure vs Validation

Canon Protocol makes a critical distinction between:

- **Structure-defining fields**: These declare what a specification IS
- **Validation-defining fields**: These declare what a specification ACCEPTS

### Structure-Defining Fields (Exact Versions Required)

#### The `type` Field
```yaml
# ✅ CORRECT - exact version
type: canon-protocol.org/type@0.2.0

# ❌ WRONG - cannot use operators
type: canon-protocol.org/type@^0.2.0
```

The `type` field is an identity declaration. Your specification was authored against a specific type version, and that relationship is fixed. If the type evolves to 0.2.0 with different requirements, your specification might no longer be valid.

#### The `includes` Array
```yaml
# ✅ CORRECT - exact versions for predictability
includes:
  - canon-protocol.org/page-config@0.1.0
  - traits.org/timestamped@1.0.0

# ❌ WRONG - would create unpredictable structure
includes:
  - canon-protocol.org/page-config@^0.1.0
```

When you include a type, you're composing its fields into your specification. If different tools resolve `^0.1.0` to different versions, your specification would have different fields depending on which tool processed it. This breaks predictability.

### Validation-Defining Fields (Operators Allowed)

#### Schema Ref Types
```yaml
schema:
  author:
    type: ref
    uri: "profiles.org/author@^1.0.0"  # ✅ Operators allowed
  
  reviewer:
    type: ref
    uri: "profiles.org/editor@~2.1.0"   # ✅ Operators allowed
```

These fields define what OTHER specifications this one will accept. The flexibility is intentional - you're saying "I'll accept any compatible author specification from 1.x.x". Different instances might use different versions, and that's perfectly fine.

#### Project Dependencies
```yaml
dependencies:
  - apispec.org/openapi@^3.0.0  # ✅ Operators allowed
  - tools.org/validator@~1.2.0  # ✅ Operators allowed
```

Project dependencies can use operators because they define what external specifications your project can work with.

## Why This Matters

Consider what happens if we allowed operators in structural fields:

1. **Tool A** builds your spec with `timestamped@1.0.0` (adds `created_at`, `updated_at`)
2. **Tool B** builds your spec with `timestamped@1.1.0` (adds `deleted_at` too)
3. **Tool C** builds your spec with `timestamped@1.2.0` (adds `archived_at` too)

Now the same specification has different structures! This breaks:
- Validation (which fields should exist?)
- Code generation (what code to generate?)
- Documentation (what to document?)
- Interoperability (tools disagree on structure)

## Quick Reference

| Field | Operators Allowed? | Example |
|-------|-------------------|---------|
| `type` | ❌ No | `type: example.org/api@1.0.0` |
| `includes` | ❌ No | `includes: ["traits.org/timestamped@1.0.0"]` |
| Schema `ref` URI | ✅ Yes | `uri: "profiles.org/author@^1.0.0"` |
| Instance values | ❌ No | `author: "johndoe.com/john@1.2.3"` |
| Dependencies | ✅ Yes | `dependencies: ["tools.org/cli@^2.0.0"]` |

## Best Practices

1. **Always use exact versions for `type` and `includes`** - These define your specification's structure
2. **Use operators in schema refs when appropriate** - This provides flexibility for field validation
3. **Never use operators in instance data** - References to actual specifications must be exact
4. **Document your version requirements** - Make it clear why you chose specific versions

## Common Pitfall

The most common mistake is trying to use operators in the `type` field:

```yaml
# This seems logical but is WRONG
type: canon-protocol.org/type@^0.2.0  # ❌

# Your spec needs a specific type version
type: canon-protocol.org/type@0.2.0   # ✅
```

Remember: your specification IS a specific type version, it doesn't just accept any compatible version.

## Conclusion

Version operators provide valuable flexibility, but only where that flexibility makes sense. Use them for validation rules (what you ACCEPT), never for structural declarations (what you ARE).

When in doubt, ask yourself: "If this version changes, would my specification's structure change?" If yes, use an exact version. If no, operators might be appropriate.





## Specification Content

:::info
This section displays the specification fields organized by their type definitions.
:::

### Core Properties

*These properties are defined by the base type: `canon-protocol.org/blog-post@0.1.0`*

### Post Title

![Required](https://img.shields.io/badge/required-red) ![Type: string](https://img.shields.io/badge/type-string-purple)

Understanding Version Operators in Canon Protocol

> The title of the blog post

---

### Summary

![Optional](https://img.shields.io/badge/optional-blue) ![Type: string](https://img.shields.io/badge/type-string-purple)

Learn the critical distinction between exact versions and version operators in Canon Protocol, and why getting this right is essential for specification predictability and tool compatibility.

> Brief summary or excerpt of the post

---

### Author

![Optional](https://img.shields.io/badge/optional-blue) ![Type: string](https://img.shields.io/badge/type-string-purple)

Canon Protocol Team

> Author name or identifier

---

### Publication Date

![Optional](https://img.shields.io/badge/optional-blue) ![Type: string](https://img.shields.io/badge/type-string-purple)

2024-01-30

> Date the post was published (YYYY-MM-DD)

---

### Tags

![Optional](https://img.shields.io/badge/optional-blue) ![Type: array](https://img.shields.io/badge/type-array-purple)

- documentation
- version-operators
- best-practices
- guide
- canon-protocol

> Categorization tags

---

### Composed Properties

*These properties are added through type composition:*

#### From artifact-manifest

*Properties from `canon-protocol.org/artifact-manifest@0.1.0`:*

### Artifacts

![Optional](https://img.shields.io/badge/optional-blue) ![Type: object](https://img.shields.io/badge/type-object-purple)

**content**: 
```yaml
{
  "path": "content.md",
  "type": "text/markdown",
  "description": "Main blog post content explaining version operators in Canon Protocol",
  "primary": true
}
```

> Additional files that are part of this specification

---





## Source Files

:::info
These are the source files from the Canon Protocol registry for this specification.
:::

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="canon-yml" label="canon.yml">

[View on GitHub](https://github.com/canon-protocol/canon/tree/main/canon-protocol.org/version-operators-explained/0.1.0/canon.yml) | [View Raw](https://raw.githubusercontent.com/canon-protocol/canon/main/canon-protocol.org/version-operators-explained/0.1.0/canon.yml)

```yaml
# Understanding Version Operators in Canon Protocol
canon: "1.0"
type: canon-protocol.org/blog-post@0.1.0
metadata:
  id: version-operators-explained
  title: "Version Operators Explained"
  version: 0.1.0
  publisher: canon-protocol.org
  description: "A comprehensive guide to when and where to use version operators in Canon Protocol"

includes:
  - canon-protocol.org/artifact-manifest@0.1.0

# Page configuration
page_order: 50
page_labels:
  - text: "Guide"
    type: "category"
    variant: "info"
    icon: "book-open"
    tooltip: "Essential reading for Canon Protocol users"

# Blog post content
title: "Understanding Version Operators in Canon Protocol"

summary: "Learn the critical distinction between exact versions and version operators in Canon Protocol, and why getting this right is essential for specification predictability and tool compatibility."

author: "Canon Protocol Team"

date: "2024-01-30"

# Declare the markdown content file
artifacts:
  content:
    path: "content.md"
    type: "text/markdown"
    description: "Main blog post content explaining version operators in Canon Protocol"
    primary: true

tags:
  - "documentation"
  - "version-operators"
  - "best-practices"
  - "guide"
  - "canon-protocol"
```

  </TabItem>
  <TabItem value="content-md" label="⭐ content.md">

> Main blog post content explaining version operators in Canon Protocol

[View on GitHub](https://github.com/canon-protocol/canon/tree/main/canon-protocol.org/version-operators-explained/0.1.0/content.md) | [View Raw](https://raw.githubusercontent.com/canon-protocol/canon/main/canon-protocol.org/version-operators-explained/0.1.0/content.md)

````markdown
# Understanding Version Operators in Canon Protocol

One of the most important concepts in Canon Protocol is knowing when to use exact versions versus version operators (`^` and `~`). Getting this wrong can break tooling and create unpredictable specifications.

## The Golden Rule

**Version operators are ONLY allowed in schema ref types and project dependencies.**

Everything else MUST use exact versions. Let's understand why.

## Structure vs Validation

Canon Protocol makes a critical distinction between:

- **Structure-defining fields**: These declare what a specification IS
- **Validation-defining fields**: These declare what a specification ACCEPTS

### Structure-Defining Fields (Exact Versions Required)

#### The `type` Field
```yaml
# ✅ CORRECT - exact version
type: canon-protocol.org/type@0.2.0

# ❌ WRONG - cannot use operators
type: canon-protocol.org/type@^0.2.0
```

The `type` field is an identity declaration. Your specification was authored against a specific type version, and that relationship is fixed. If the type evolves to 0.2.0 with different requirements, your specification might no longer be valid.

#### The `includes` Array
```yaml
# ✅ CORRECT - exact versions for predictability
includes:
  - canon-protocol.org/page-config@0.1.0
  - traits.org/timestamped@1.0.0

# ❌ WRONG - would create unpredictable structure
includes:
  - canon-protocol.org/page-config@^0.1.0
```

When you include a type, you're composing its fields into your specification. If different tools resolve `^0.1.0` to different versions, your specification would have different fields depending on which tool processed it. This breaks predictability.

### Validation-Defining Fields (Operators Allowed)

#### Schema Ref Types
```yaml
schema:
  author:
    type: ref
    uri: "profiles.org/author@^1.0.0"  # ✅ Operators allowed
  
  reviewer:
    type: ref
    uri: "profiles.org/editor@~2.1.0"   # ✅ Operators allowed
```

These fields define what OTHER specifications this one will accept. The flexibility is intentional - you're saying "I'll accept any compatible author specification from 1.x.x". Different instances might use different versions, and that's perfectly fine.

#### Project Dependencies
```yaml
dependencies:
  - apispec.org/openapi@^3.0.0  # ✅ Operators allowed
  - tools.org/validator@~1.2.0  # ✅ Operators allowed
```

Project dependencies can use operators because they define what external specifications your project can work with.

## Why This Matters

Consider what happens if we allowed operators in structural fields:

1. **Tool A** builds your spec with `timestamped@1.0.0` (adds `created_at`, `updated_at`)
2. **Tool B** builds your spec with `timestamped@1.1.0` (adds `deleted_at` too)
3. **Tool C** builds your spec with `timestamped@1.2.0` (adds `archived_at` too)

Now the same specification has different structures! This breaks:
- Validation (which fields should exist?)
- Code generation (what code to generate?)
- Documentation (what to document?)
- Interoperability (tools disagree on structure)

## Quick Reference

| Field | Operators Allowed? | Example |
|-------|-------------------|---------|
| `type` | ❌ No | `type: example.org/api@1.0.0` |
| `includes` | ❌ No | `includes: ["traits.org/timestamped@1.0.0"]` |
| Schema `ref` URI | ✅ Yes | `uri: "profiles.org/author@^1.0.0"` |
| Instance values | ❌ No | `author: "johndoe.com/john@1.2.3"` |
| Dependencies | ✅ Yes | `dependencies: ["tools.org/cli@^2.0.0"]` |

## Best Practices

1. **Always use exact versions for `type` and `includes`** - These define your specification's structure
2. **Use operators in schema refs when appropriate** - This provides flexibility for field validation
3. **Never use operators in instance data** - References to actual specifications must be exact
4. **Document your version requirements** - Make it clear why you chose specific versions

## Common Pitfall

The most common mistake is trying to use operators in the `type` field:

```yaml
# This seems logical but is WRONG
type: canon-protocol.org/type@^0.2.0  # ❌

# Your spec needs a specific type version
type: canon-protocol.org/type@0.2.0   # ✅
```

Remember: your specification IS a specific type version, it doesn't just accept any compatible version.

## Conclusion

Version operators provide valuable flexibility, but only where that flexibility makes sense. Use them for validation rules (what you ACCEPT), never for structural declarations (what you ARE).

When in doubt, ask yourself: "If this version changes, would my specification's structure change?" If yes, use an exact version. If no, operators might be appropriate.
````

  </TabItem>
</Tabs>


